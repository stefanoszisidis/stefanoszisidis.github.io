<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music - RunTheCode.gr</title>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-QR6Y23BYRX"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-QR6Y23BYRX');
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <style>
    /* Additional styles for playlist selection */
    .year-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .year-btn {
      padding: 0.75rem 1.5rem;
      background-color: rgba(56, 189, 248, 0.1);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }

    .year-btn:hover {
      background-color: rgba(56, 189, 248, 0.2);
      border-color: var(--accent-primary);
    }

    .year-btn.active {
      background-color: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-body);
    }

    .quarter-selector {
      display: none;
      gap: 0.75rem;
      margin-top: 1rem;
      flex-wrap: wrap;
    }

    .quarter-selector.visible {
      display: flex;
    }

    .quarter-btn {
      padding: 0.5rem 1rem;
      background-color: var(--bg-body);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .quarter-btn:hover {
      background-color: rgba(56, 189, 248, 0.1);
      border-color: var(--accent-primary);
      color: var(--text-primary);
    }

    .quarter-btn.active {
      background-color: rgba(56, 189, 248, 0.15);
      border-color: var(--accent-primary);
      color: var(--accent-primary);
      font-weight: 600;
    }

    .selection-status {
      margin-top: 1.5rem;
      display: none;
    }

    .selection-status.visible {
      display: block;
    }

    .music-content {
      display: none;
    }

    .music-content.visible {
      display: block;
    }

    /* Flex container for playlist cards */
    .playlist-info .container {
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
    }

    .info-card {
      flex: 1;
      min-width: 300px;
    }

    /* Genre specific styles */
    .genre-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .genre-btn {
      padding: 0.75rem 1.5rem;
      background-color: rgba(16, 185, 129, 0.1);
      /* Green tint for genre */
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }

    .genre-btn:hover {
      background-color: rgba(16, 185, 129, 0.2);
      border-color: #10b981;
    }

    .genre-btn.active {
      background-color: #10b981;
      border-color: #10b981;
      color: var(--bg-body);
    }

    /* Stats Card Styles */
    .stats-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 1.5rem;
      margin-top: 2rem;
    }

    .stats-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.75rem;
    }

    .stats-header h3 {
      font-size: 1.1rem;
      color: var(--text-primary);
      margin: 0;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .total-plays {
      font-size: 0.9rem;
      color: var(--accent-secondary);
      font-weight: 600;
      background: rgba(244, 63, 94, 0.1);
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
    }

    .top-playlists-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .stat-item {
      display: flex;
      align-items: center;
      padding: 0.75rem 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-item:last-child {
      border-bottom: none;
    }

    .stat-rank {
      font-weight: 700;
      color: var(--text-secondary);
      width: 30px;
      font-size: 0.9rem;
    }

    .stat-name {
      flex: 1;
      color: var(--text-primary);
      font-weight: 500;
      font-size: 0.95rem;
    }

    .stat-value {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .stat-item.clickable {
      cursor: pointer;
      transition: background-color 0.2s ease;
      border-radius: 6px;
      padding: 0.75rem 0.5rem;
      /* Add side padding for hover effect */
      margin: 0 -0.5rem;
      /* Negative margin to align with text */
    }

    .stat-item.clickable:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .stat-item.clickable:hover .stat-name {
      color: var(--accent-primary);
    }

    /* Compilation specific styles */
    .compilation-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .compilation-btn {
      padding: 0.75rem 1.5rem;
      background-color: rgba(168, 85, 247, 0.1);
      /* Purple tint for compilations */
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }

    .compilation-btn:hover {
      background-color: rgba(168, 85, 247, 0.2);
      border-color: #a855f7;
    }

    .compilation-btn.active {
      background-color: #a855f7;
      border-color: #a855f7;
      color: var(--bg-body);
    }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="container">
      <a href="index.html" class="site-title">RunTheCode.gr</a>
      <nav class="breadcrumb">
        <a href="index.html">Home</a>
        <span class="separator">/</span>
        <span class="current">Music</span>
      </nav>
    </div>
  </header>

  <main>
    <section class="music-hero">
      <div class="container">
        <h1>Music</h1>
        <p class="music-subtitle">Curated quarterly playlists featuring handpicked tracks</p>
      </div>
    </section>

    <section class="playlist-info">
      <div class="container">
        <!-- Card 1: Quarterly Collections -->
        <div class="info-card">
          <h2>Quarterly Music Collections</h2>
          <p>Every three months, I curate a special playlist of songs that resonated with me during that period.
            Each collection represents a musical journey through the quarter.</p>

          <p style="margin-top: 1.5rem; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">Select a
            year:</p>

          <!-- Year Selection -->
          <div class="year-selector">
            <button class="year-btn" data-year="2025">2025</button>
            <button class="year-btn" data-year="2024">2024</button>
            <button class="year-btn" data-year="2023">2023</button>
            <button class="year-btn" data-year="2022">2022</button>
          </div>

          <!-- Quarter Selection (dynamically populated) -->
          <div id="quarter-selector" class="quarter-selector"></div>

          <p id="selection-status" class="current-playlist selection-status">
            Currently selected: <strong><span id="selected-playlist"></span></strong>
          </p>
        </div>

        <!-- Card 2: Genre Based Playlists -->
        <div class="info-card">
          <h2>Genre Based Playlists</h2>
          <p>Exploring specific sounds and vibes. These collections focus on deep dives into specific genres, bringing
            together tracks that define a mood.</p>

          <p style="margin-top: 1.5rem; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">Select a
            genre:</p>

          <!-- Genre Selection -->
          <div id="genre-selector" class="genre-selector">
            <!-- Dynamically populated -->
          </div>

          <!-- Genre Year Selection (dynamically populated) -->
          <div id="genre-year-selector" class="quarter-selector"></div>

          <p id="genre-selection-status" class="current-playlist selection-status">
            Currently selected: <strong><span id="selected-genre-playlist"></span></strong>
          </p>
        </div>

        <!-- Card 3: Compilations -->
        <div class="info-card">
          <h2>Compilations</h2>
          <p>Themed YouTube playlists I've curated over time. These collections bring together tracks around specific
            moods, styles, or vibes.</p>

          <p style="margin-top: 1.5rem; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">Select a
            compilation:</p>

          <!-- Compilation Selection -->
          <div id="compilation-selector" class="compilation-selector">
            <!-- Dynamically populated -->
          </div>

          <p id="compilation-selection-status" class="current-playlist selection-status">
            Currently selected: <strong><span id="selected-compilation"></span></strong>
          </p>
        </div>
      </div>

      <!-- Live Stats Section -->
      <div class="container">
        <div class="stats-card">
          <div class="stats-header">
            <h3><span style="font-size: 1.2rem;">ðŸ”¥</span> Live Stats</h3>
            <span class="total-plays"><span id="total-plays-count">...</span> Total Plays</span>
          </div>
          <div>
            <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0.75rem;">Top Trending Playlists:
            </p>
            <ul id="top-playlists-list" class="top-playlists-list">
              <li class="stat-item" style="justify-content: center; color: var(--text-secondary);">Loading stats...</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section id="music-content" class="music-content">
      <div class="container">
        <div class="playlist-grid">
          <div class="video-container">
            <div class="video-wrapper">
              <div id="youtube-player"></div>
            </div>
          </div>

          <div class="tracklist-container">
            <h3>Tracklist</h3>
            <div id="tracklist" class="tracklist">
              <!-- Tracks will be dynamically loaded -->
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p>&copy; 2026 RunTheCode.gr</p>
    </div>
  </footer>

  <script type="module">
    import { initMusicStats, trackPlay } from './js/firebase.js';

    // Initialize stats when page loads
    document.addEventListener('DOMContentLoaded', () => {
      initMusicStats();
    });

    // Expose trackPlay to the global scope for the main script to use
    window.trackPlayFirebase = trackPlay;

    // Global function to play a playlist by name (called from stats click)
    window.playPlaylistByName = function (name) {
      console.log('Playing from stats:', name);

      // 1. Search Compilations
      if (typeof compilations !== 'undefined' && compilations[name]) {
        loadCompilation(name);
        // Scroll to player
        document.getElementById('music-content').scrollIntoView({ behavior: 'smooth' });
        return;
      }

      // 2. Search Quarterly (Format: "2025 Q4")
      if (typeof playlists !== 'undefined') {
        // Reverse Search to find year/quarter
        for (const year in playlists) {
          for (const q in playlists[year]) {
            const pName = playlists[year][q].name; // usually "2025 Q4"? 
            // Wait, name property in JSON might be "2025 Q4" or "Q4"? Checking...
            // Actually playlists[year][quarter].name is usually just the Quarter name e.g. "Q4" ??
            // No, let's check loadPlaylist logic safely.
            // Logic: displayPlaylist uses playlist.name.
            // In playlists.json structure?
          }
        }

        // Simpler: Try to parse "2025 Q4"
        const parts = name.split(' ');
        if (parts.length === 2) {
          const year = parts[0];
          const q = parts[1];
          if (playlists && playlists[year] && playlists[year][q]) {
            // We need to trigger the UI (buttons) to keep state consistent
            // Click the year button
            const yearBtn = document.querySelector(`.year-btn[data-year="${year}"]`);
            if (yearBtn) yearBtn.click();

            // Wait for quarters to populate then click quarter
            setTimeout(() => {
              const qBtn = document.querySelector(`.quarter-btn[data-quarter="${q}"]`);
              if (qBtn) qBtn.click();
              document.getElementById('music-content').scrollIntoView({ behavior: 'smooth' });
            }, 100);
            return;
          }
        }
      }

      // 3. Search Genre (Ambiguous if name is just "2024", but let's try)
      // If name is just a number like "2024", it might be a genre year.
      if (!isNaN(name)) {
        // Find a genre that has this year?
        // This is ambiguous. Maybe just ignore or pick first.
        // Let's iterate genrePlaylists
        if (typeof genrePlaylists !== 'undefined') {
          for (const genre in genrePlaylists) {
            if (genrePlaylists[genre][name]) {
              // Found one!
              // Click genre button
              const genreBtn = document.querySelector(`.genre-btn[data-genre="${genre}"]`);
              if (genreBtn) genreBtn.click();

              setTimeout(() => {
                const qBtn = document.querySelector(`.quarter-btn[data-quarter="${name}"]`); // Class is quarter-btn used for year
                if (qBtn) qBtn.click();
                document.getElementById('music-content').scrollIntoView({ behavior: 'smooth' });
              }, 100);
              return;
            }
          }
        }
      }

      console.warn('Playlist not found:', name);
    };
  </script>

  <script>
    // Playlist data structure (populated from JSON)
    let playlists = {};
    let genrePlaylists = {};
    let compilations = {};

    // Player state variables
    let player;
    let isAPIReady = false;
    let playerInitialized = false;
    let updateInterval;
    let currentYear;
    let currentQuarter;

    let lastPlayingIndex = -1;
    // Play All State
    let isPlayAllMode = false;
    let playAllQueue = [];
    let playAllIndex = 0;
    let currentGenre = null; // Track current genre for chaining

    // Load YouTube IFrame API
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    // Called when API is ready (global callback required by YouTube API)
    function onYouTubeIframeAPIReady() {
      isAPIReady = true;
      console.log('YouTube API ready');
    }

    // Fallback data (mirrors playlists.json)
    // Fallback data removed to ensure single source of truth (data/playlists.json)

    // Load playlist data from JSON file
    async function loadPlaylistData() {
      console.log('Attempting to load data/playlists.json');
      try {
        // Aggressive cache busting using timestamp
        const timestamp = new Date().getTime();
        const response = await fetch('data/playlists.json?v=' + timestamp, {
          cache: "no-store",
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Playlists loaded successfully:', data);

        // Populate global variables
        playlists = data.quarterly;
        genrePlaylists = data.genres;

        // Log 2025 Q4 tracks for debugging
        if (playlists['2025'] && playlists['2025']['Q4']) {
          console.log('2025 Q4 Tracks loaded:', playlists['2025']['Q4'].tracks);
        }

        // Load compilations data
        await loadCompilationData();

        // Initialize UI only after all data is loaded
        initializeUI();

        // If API became ready while we were fetching data, checking here ensures nothing was missed
        if (isAPIReady && !playerInitialized) {
          console.log('API ready and Data loaded');
        }

      } catch (error) {
        console.error('Error fetching playlists.json:', error);

        // Show error to user with more specific details
        const quarterlyCard = document.querySelector('.info-card');

        if (quarterlyCard) {
          quarterlyCard.innerHTML = `
                <h2>Quarterly Music Collections</h2>
                <div style="padding: 1rem; background-color: rgba(239, 68, 68, 0.1); border: 1px solid var(--accent-secondary); border-radius: 6px; color: var(--accent-secondary);">
                    <p style="font-weight: 600; margin-bottom: 0.5rem;">Unable to load playlists</p>
                    <p style="font-size: 0.9rem;">Error Details: ${error.message}</p>
                    <p style="font-size: 0.9rem; margin-top: 0.5rem;">If you are viewing this file locally (file://), browsers often block this.</p>
                    <p style="font-size: 0.9rem;"><strong>Tip:</strong> Try using a local server (e.g., Live Server in VS Code) or check the Console (F12) for more info.</p>
                </div>
            `;
        }
      }
    }

    // Initialize UI
    function initializeUI() {
      setupYearButtons();
      setupGenreButtons();
      setupCompilationButtons();
    }

    // Load compilation data from JSON file
    async function loadCompilationData() {
      console.log('Attempting to load data/compilations.json');
      try {
        const timestamp = new Date().getTime();
        const response = await fetch('data/compilations.json?v=' + timestamp, {
          cache: "no-store",
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Compilations loaded successfully:', data);
        compilations = data.compilations;

      } catch (error) {
        console.error('Error fetching compilations.json:', error);
        // Continue without compilations - don't block the page
        compilations = {};
      }
    }

    // Setup genre button handlers
    function setupGenreButtons() {
      const genreSelector = document.getElementById('genre-selector');
      genreSelector.innerHTML = ''; // Clear existing

      Object.keys(genrePlaylists).forEach(genre => {
        const btn = document.createElement('button');
        btn.className = 'genre-btn';
        btn.textContent = genre;
        btn.dataset.genre = genre;

        btn.addEventListener('click', function () {
          // Deactivate quarterly selection
          document.querySelectorAll('.year-btn').forEach(b => b.classList.remove('active'));
          document.getElementById('quarter-selector').classList.remove('visible');
          document.getElementById('selection-status').classList.remove('visible');

          // Deactivate compilation selection
          document.querySelectorAll('.compilation-btn').forEach(b => b.classList.remove('active'));
          document.getElementById('compilation-selection-status').classList.remove('visible');

          // Update active state
          document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');

          // Update current genre
          updateGenreYearButtons(genre);

          // Auto-select first available year for this genre
          const years = Object.keys(genrePlaylists[genre]);
          if (years.length > 0) {
            // Trigger click on first genre year button to load playlist
            // Sort years in descending order (newest first)
            const sortedYears = years.sort((a, b) => b - a);
            // We need to wait for buttons to be created in updateGenreYearButtons
            setTimeout(() => {
              const firstYearBtn = document.querySelector('#genre-year-selector .quarter-btn');
              if (firstYearBtn) {
                firstYearBtn.click();
              }
            }, 0);
          }
        });

        genreSelector.appendChild(btn);
      });
    }

    // Setup compilation button handlers
    function setupCompilationButtons() {
      const compilationSelector = document.getElementById('compilation-selector');
      if (!compilationSelector) return;

      compilationSelector.innerHTML = ''; // Clear existing

      Object.keys(compilations).forEach(name => {
        const btn = document.createElement('button');
        btn.className = 'compilation-btn';
        btn.textContent = name;
        btn.dataset.compilation = name;

        btn.addEventListener('click', function () {
          // Deactivate quarterly selection
          document.querySelectorAll('.year-btn').forEach(b => b.classList.remove('active'));
          document.getElementById('quarter-selector').classList.remove('visible');
          document.getElementById('selection-status').classList.remove('visible');

          // Deactivate genre selection
          document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
          document.getElementById('genre-year-selector').classList.remove('visible');
          document.getElementById('genre-selection-status').classList.remove('visible');

          // Update active state for compilations
          document.querySelectorAll('.compilation-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');

          loadCompilation(name);
        });

        compilationSelector.appendChild(btn);
      });
    }

    // Load a specific compilation
    function loadCompilation(name) {
      const playlist = compilations[name];
      if (!playlist) return;

      // Reset quarterly and genre selection text
      document.getElementById('selected-playlist').textContent = "";
      document.getElementById('selected-genre-playlist').textContent = "";

      displayPlaylist(playlist, 'compilation-selection-status', 'selected-compilation');
    }

    // Update genre year buttons
    function updateGenreYearButtons(genre) {
      const selector = document.getElementById('genre-year-selector');
      selector.innerHTML = '';
      selector.classList.add('visible');

      const years = genrePlaylists[genre];
      if (!years) return;

      Object.keys(years).forEach((year, index) => {
        const btn = document.createElement('button');
        btn.className = 'quarter-btn';
        btn.textContent = year;
        btn.dataset.year = year;

        btn.addEventListener('click', function () {
          // Deactivate normal quarterly buttons if any remain
          document.querySelectorAll('.quarter-selector:not(#genre-year-selector) .quarter-btn').forEach(b => b.classList.remove('active'));

          const btns = document.querySelectorAll('#genre-year-selector .quarter-btn');
          btns.forEach(b => b.classList.remove('active'));
          this.classList.add('active');

          loadGenrePlaylist(genre, year);
        });

        selector.appendChild(btn);
      });
      // Add "Play All" button for Genre
      if (Object.keys(years).length > 0) {
        const playAllBtn = document.createElement('button');
        playAllBtn.className = 'quarter-btn play-all-btn';
        playAllBtn.textContent = 'Play All';

        playAllBtn.addEventListener('click', function () {
          // Deactivate normal buttons
          document.querySelectorAll('#genre-year-selector .quarter-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');

          // Setup Chain
          isPlayAllMode = true;
          currentGenre = genre;
          // Sort keys descending (newest first)
          const sortedYears = Object.keys(genrePlaylists[genre]).sort((a, b) => b - a);
          playAllQueue = sortedYears;
          playAllIndex = 0;

          loadGenrePlaylist(genre, sortedYears[0]);
        });
        selector.appendChild(playAllBtn);
      }
    }


    function loadGenrePlaylist(genre, year) {
      const playlist = genrePlaylists[genre][year];
      if (!playlist) return;

      // Reset quarterly selection text
      document.getElementById('selected-playlist').textContent = "";

      displayPlaylist(playlist, 'genre-selection-status', 'selected-genre-playlist');
    }

    // Setup year button handlers
    function setupYearButtons() {
      const yearButtons = document.querySelectorAll('.year-btn');
      yearButtons.forEach(btn => {
        btn.addEventListener('click', function () {
          const year = this.dataset.year;

          // Deactivate genre selection
          document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
          document.getElementById('genre-year-selector').classList.remove('visible');
          document.getElementById('genre-selection-status').classList.remove('visible');

          // Deactivate compilation selection
          document.querySelectorAll('.compilation-btn').forEach(b => b.classList.remove('active'));
          document.getElementById('compilation-selection-status').classList.remove('visible');

          // Update active state
          yearButtons.forEach(b => b.classList.remove('active'));
          this.classList.add('active');

          // Update current year
          currentYear = year;

          // Reset player initialization flag for new year
          playerInitialized = false;

          // Show and update quarter buttons
          updateQuarterButtons(year);

          // Auto-select first available quarter
          const quarters = Object.keys(playlists[year]);
          if (quarters.length > 0) {
            currentQuarter = quarters[0];
            // Trigger click on first quarter button to load playlist
            setTimeout(() => {
              const firstQuarterBtn = document.querySelector('#quarter-selector .quarter-btn');
              if (firstQuarterBtn) {
                firstQuarterBtn.click();
              }
            }, 0);
          }
        });
      });
    }

    // Update quarter buttons based on selected year
    function updateQuarterButtons(year) {
      const quarterSelector = document.getElementById('quarter-selector');
      quarterSelector.innerHTML = '';
      quarterSelector.classList.add('visible');

      const quarters = playlists[year];
      if (!quarters) return;

      // Create buttons for each quarter
      Object.keys(quarters).forEach((quarter, index) => {
        const btn = document.createElement('button');
        btn.className = 'quarter-btn';
        btn.textContent = quarter;
        btn.dataset.quarter = quarter;

        btn.addEventListener('click', function () {
          const quarterBtns = document.querySelectorAll('.quarter-btn');
          quarterBtns.forEach(b => b.classList.remove('active'));
          this.classList.add('active');

          // Manual click cancels Play All mode
          isPlayAllMode = false;

          currentQuarter = quarter;
          loadPlaylist(currentYear, quarter);
        });

        quarterSelector.appendChild(btn);
      });

      // Add "Play All" button
      if (Object.keys(quarters).length > 0) {
        const playAllBtn = document.createElement('button');
        playAllBtn.className = 'quarter-btn play-all-btn';
        playAllBtn.textContent = 'Play All';

        playAllBtn.addEventListener('click', function () {
          const quarterBtns = document.querySelectorAll('.quarter-btn');
          quarterBtns.forEach(b => b.classList.remove('active'));
          this.classList.add('active');

          isPlayAllMode = true;
          // Sort quarters? usually they are keys. relying on object order or explicit sort?
          // 'Q1', 'Q2', 'Q3', 'Q4' -> Alphabetical sort works.
          // user might have 'Winter', 'Sep-Dec' -> 'Sep-Dec', 'Winter' (S comes before W).
          // Let's rely on standard Object.keys but verify sort.
          // Actually, standard sort for Quarters might be tricky if names vary. 
          // For now, let's trust simple alphanumeric sort or key order.
          playAllQueue = Object.keys(quarters).sort();
          // If 2022 has 'Winter', 'Sep-Dec', 'Sep-Dec' comes first. That's probably reverse chronological? 
          // Winter (early) -> Sep-Dec (late). Wait. Winter in Jan? Or Winter in Dec?
          // 2022.Winter is usually Q1. 2022.Sep-Dec is Q4.
          // Alphabetic: 'Sep-Dec', 'Winter'. Order: Q4, Q1. Wrong.
          // Let's just use the keys as they appear if we assume insertion order (not guaranteed but often coincident)
          // OR specifically sort Q1, Q2, Q3, Q4.
          // For named ones, we might need a smart sort.
          // For 2022: Winter, Sep-Dec. 
          // Let's just use the raw keys for now and see.
          playAllIndex = 0;

          loadPlaylist(year, playAllQueue[0]);
        });
        quarterSelector.appendChild(playAllBtn);
      }
    }

    // Load a specific playlist (Quarterly)
    function loadPlaylist(year, quarter) {
      const playlist = playlists[year][quarter];
      if (!playlist) return;

      // Reset genre selection text
      document.getElementById('selected-genre-playlist').textContent = "";

      displayPlaylist(playlist, 'selection-status', 'selected-playlist');
    }

    // Shared function to display playlist
    function displayPlaylist(playlist, statusId, titleId) {
      console.log('Loading playlist:', playlist.name);

      // GA4 Event: Playlist Selected
      if (typeof gtag === 'function') {
        gtag('event', 'select_content', {
          content_type: 'playlist',
          item_id: playlist.name
        });
      }

      // Show the music content section
      const musicContent = document.getElementById('music-content');
      musicContent.classList.add('visible');

      // Show and update selected playlist text
      const selectionStatus = document.getElementById(statusId);
      selectionStatus.classList.add('visible');
      document.getElementById(titleId).textContent = playlist.name;

      // Load tracks
      const tracklistDiv = document.getElementById('tracklist');
      tracklistDiv.innerHTML = '';

      playlist.tracks.forEach((track, index) => {
        const trackItem = document.createElement('div');
        trackItem.className = 'track-item';
        trackItem.dataset.index = index;

        const trackNumber = document.createElement('span');
        trackNumber.className = 'track-number';
        trackNumber.textContent = String(index + 1).padStart(2, '0');

        const trackName = document.createElement('span');
        trackName.className = 'track-name';
        trackName.textContent = track;

        trackItem.appendChild(trackNumber);
        trackItem.appendChild(trackName);
        tracklistDiv.appendChild(trackItem);
      });

      // Reset last playing index when changing playlists
      lastPlayingIndex = -1;

      // Initialize or update the player
      // Always re-initialize to ensure clean state and avoid transition issues
      initializePlayer(playlist.id);

      // Attach click handlers immediately so user can select tracks even if player errors
      setupTrackClickHandlers();
    }

    // Initialize the YouTube player
    function initializePlayer(playlistId) {
      console.log('Initializing player with playlist:', playlistId);

      // Wait for API if not ready
      if (!isAPIReady) {
        console.log('Waiting for YouTube API...');
        setTimeout(() => initializePlayer(playlistId), 200);
        return;
      }

      // Clear existing interval if any
      if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
      }

      // Destroy existing player if any
      if (player) {
        try {
          // Get the parent before destroying, to know where to put the new one back
          const currentElement = document.getElementById('youtube-player');
          const parent = currentElement ? currentElement.parentNode : document.querySelector('.video-wrapper');

          player.destroy();
          player = null;

          // Re-create the div if it was removed by destroy()
          if (!document.getElementById('youtube-player') && parent) {
            console.log('Re-creating player container');
            const newDiv = document.createElement('div');
            newDiv.id = 'youtube-player';
            parent.appendChild(newDiv);
          }

        } catch (e) {
          console.log('Error destroying player:', e);
        }
      }

      // Ensure container exists (just in case)
      if (!document.getElementById('youtube-player')) {
        const wrapper = document.querySelector('.video-wrapper');
        if (wrapper) {
          const newDiv = document.createElement('div');
          newDiv.id = 'youtube-player';
          wrapper.appendChild(newDiv);
        }
      }

      // Create new player
      player = new YT.Player('youtube-player', {
        height: '315',
        width: '560',
        playerVars: {
          listType: 'playlist',
          list: playlistId,
          enablejsapi: 1,
          autoplay: 1
        },
        events: {
          'onReady': onPlayerReady,
          'onStateChange': onPlayerStateChange,
          'onError': onPlayerError
        }
      });

      playerInitialized = true;
    }

    // Setup track click handlers
    function setupTrackClickHandlers() {
      const trackItems = document.querySelectorAll('.track-item');
      trackItems.forEach(trackItem => {
        // Remove old listeners by cloning
        const newTrackItem = trackItem.cloneNode(true);
        trackItem.parentNode.replaceChild(newTrackItem, trackItem);

        newTrackItem.addEventListener('click', function () {
          const trackIndex = parseInt(this.getAttribute('data-index'));
          console.log('Track clicked:', trackIndex);

          // Play the selected track
          if (player && player.playVideoAt) {
            player.playVideoAt(trackIndex);
          }
        });
      });
    }

    // Function to update active track highlight
    function updateActiveTrack() {
      if (!player || !player.getPlaylistIndex) return;

      try {
        const currentIndex = player.getPlaylistIndex();
        const trackItems = document.querySelectorAll('.track-item');

        // Remove active class from all tracks
        trackItems.forEach(item => item.classList.remove('active'));

        // Add active class to currently playing track
        const currentTrack = document.querySelector(`.track-item[data-index="${currentIndex}"]`);
        if (currentTrack) {
          currentTrack.classList.add('active');

          // Only scroll if the track has changed
          if (currentIndex !== lastPlayingIndex) {
            currentTrack.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            lastPlayingIndex = currentIndex;
          }
        }
      } catch (error) {
        // Silently handle errors (player might not be ready)
      }
    }



    // Handle Player Error (e.g. video unavailable)
    function onPlayerError(event) {
      console.log('Player Error:', event.data);
      // 100: Video not found
      // 101, 150: Video owner does not allow embedding
      if (event.data === 100 || event.data === 101 || event.data === 150) {
        console.log('Skipping unavailable video...');
        if (player && player.nextVideo) {
          // Add a small delay to avoid rapid skipping loops
          setTimeout(() => {
            player.nextVideo();
          }, 500);
        }
      }
    }

    function onPlayerReady(event) {
      console.log('Player ready');
      setupTrackClickHandlers();

      // Clear existing interval if any
      if (updateInterval) {
        clearInterval(updateInterval);
      }

      // Start polling for current track (every 500ms)
      updateInterval = setInterval(updateActiveTrack, 500);

      // Initial update
      setTimeout(updateActiveTrack, 500);

      // Force play if in Play All mode (crucial for auto-advance to work seamlessly)
      if (isPlayAllMode && event.target && event.target.playVideo) {
        console.log('Play All Mode: Forcing playback');
        event.target.playVideo();
      }
    }

    function onPlayerStateChange(event) {
      console.log('Player state changed:', event.data);

      // GA4 Event: Track Played
      if (event.data === YT.PlayerState.PLAYING) {
        if (typeof gtag === 'function') {
          // Get current track info
          let trackName = "Unknown Track";
          try {
            const currentIndex = player.getPlaylistIndex();
            trackName = document.querySelector(`.track-item[data-index="${currentIndex}"] .track-name`)?.textContent || "Unknown Track";
          } catch (e) { }

          gtag('event', 'play_track', {
            event_category: 'Music',
            event_label: trackName,
            playlist_name: document.getElementById('selected-playlist').textContent ||
              document.getElementById('selected-genre-playlist').textContent ||
              document.getElementById('selected-compilation').textContent
          });
        }

        // Firebase: Track Play
        if (typeof window.trackPlayFirebase === 'function') {
          const playlistName = document.getElementById('selected-playlist').textContent ||
            document.getElementById('selected-genre-playlist').textContent ||
            document.getElementById('selected-compilation').textContent;
          if (playlistName) {
            window.trackPlayFirebase(playlistName);
          }
        }
      }

      // Update immediately when state changes
      updateActiveTrack();

      // Handle "Play All" auto-advance
      // Use event.target to ensure we are referencing the player that fired the event
      const activePlayer = event.target;

      // event.data === 0 means ENDED
      if (isPlayAllMode && event.data === 0) {
        // Check if it was the LAST video in the playlist
        if (activePlayer && activePlayer.getPlaylistIndex) {
          const currentIndex = activePlayer.getPlaylistIndex();
          const playlist = activePlayer.getPlaylist();
          const playlistLength = playlist ? playlist.length : 0;

          console.log(`Play All Check: Index ${currentIndex} / Length ${playlistLength}`);

          // If we just finished the last track
          if (playlistLength > 0 && currentIndex === playlistLength - 1) {
            console.log('Finished playlist in Play All mode. Check for next...');
            playAllIndex++;
            if (playAllIndex < playAllQueue.length) {
              const nextKey = playAllQueue[playAllIndex];
              console.log('Loading next:', nextKey);

              if (currentGenre) {
                loadGenrePlaylist(currentGenre, nextKey);
              } else {
                // Default quarterly
                loadPlaylist(currentYear, nextKey);
              }
            } else {
              console.log('Play All sequence complete.');
              isPlayAllMode = false;
              currentGenre = null;
            }
          }
        }
      }
    }

    // Clean up interval when page unloads
    window.addEventListener('beforeunload', function () {
      if (updateInterval) {
        clearInterval(updateInterval);
      }
    });

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', loadPlaylistData);
  </script>
</body>

</html>